import { Layout } from '@/components/Layout';
import { InteractiveCodeBlock } from '@/components/InteractiveCodeBlock';

export const metadata = {
  title: 'PyBlog 交互式代码块示例',
  description: '学习如何在MDX文章中使用交互式Python代码块',
  date: '2024-01-20',
  readTime: '8 分钟',
  tags: ['Python', 'Tutorial', 'Interactive'],
};

<Layout
  title="PyBlog 交互式代码块示例"
  description="学习如何在MDX文章中使用交互式Python代码块，包括数据处理、可视化和机器学习示例"
>

# PyBlog 交互式代码块示例

*发布于 2024年1月20日 · 8分钟阅读*

---

欢迎来到PyBlog！这是一个支持**交互式Python代码块**的现代博客平台。在这篇文章中，我们将展示如何在MDX格式的文章中嵌入可执行的Python代码。

## 🚀 基础功能演示

让我们从一个简单的"Hello World"开始：

<InteractiveCodeBlock
  code={`print("Hello, PyBlog!")
print("欢迎来到交互式Python博客！")

# 让我们做一些基础的数学运算
a = 10
b = 20
print(f"a + b = {a + b}")
print(f"a * b = {a * b}")

# 字符串操作
name = "PyBlog"
message = f"我喜欢使用 {name} 来学习Python！"
print(message)`}
  title="Hello World示例"
  description="最基础的Python代码示例"
  height={250}
/>

## 📊 数据处理示例

Python最强大的功能之一就是数据处理。让我们使用一些内置的数据结构：

<InteractiveCodeBlock
  code={`# 创建一个学生成绩数据
students = [
    {"name": "张三", "math": 85, "english": 92, "science": 78},
    {"name": "李四", "math": 90, "english": 85, "science": 88},
    {"name": "王五", "math": 78, "english": 89, "science": 92},
    {"name": "赵六", "math": 95, "english": 87, "science": 85},
]

# 计算每个学生的平均分
print("学生成绩统计:")
print("-" * 40)

for student in students:
    avg = (student["math"] + student["english"] + student["science"]) / 3
    print(f"{student['name']}: 平均分 {avg:.1f}")

# 找出数学成绩最高的学生
best_math = max(students, key=lambda x: x["math"])
print(f"\n数学成绩最高: {best_math['name']} ({best_math['math']}分)")

# 计算全班各科平均分
math_avg = sum(s["math"] for s in students) / len(students)
english_avg = sum(s["english"] for s in students) / len(students)
science_avg = sum(s["science"] for s in students) / len(students)

print(f"\n全班各科平均分:")
print(f"数学: {math_avg:.1f}")
print(f"英语: {english_avg:.1f}")
print(f"科学: {science_avg:.1f}")`}
  title="数据处理示例"
  description="使用Python处理学生成绩数据"
  height={400}
/>

## 🔢 数学计算与算法

让我们尝试一些更复杂的数学计算：

<InteractiveCodeBlock
  code={`import math
import random

# 生成随机数据并进行统计分析
random.seed(42)  # 设置随机种子以获得可重复的结果
data = [random.randint(1, 100) for _ in range(20)]

print("随机数据:", data)
print(f"数据点数量: {len(data)}")

# 基础统计
mean = sum(data) / len(data)
median = sorted(data)[len(data) // 2]
minimum = min(data)
maximum = max(data)
range_val = maximum - minimum

print(f"\n统计信息:")
print(f"平均值: {mean:.2f}")
print(f"中位数: {median}")
print(f"最小值: {minimum}")
print(f"最大值: {maximum}")
print(f"范围: {range_val}")

# 计算标准差
variance = sum((x - mean) ** 2 for x in data) / len(data)
std_dev = math.sqrt(variance)
print(f"标准差: {std_dev:.2f}")

# 找出异常值（超过2个标准差的值）
outliers = [x for x in data if abs(x - mean) > 2 * std_dev]
print(f"\n异常值 (超过2个标准差): {outliers}")

# 简单的数值分析
print(f"\n数值分布:")
for i in range(0, 101, 20):
    count = sum(1 for x in data if i <= x < i + 20)
    bar = "█" * count
    print(f"{i:2d}-{i+19:2d}: {bar} ({count})")`}
  title="数学计算示例"
  description="随机数据的统计分析"
  height={450}
/>

## 🎯 实用算法示例

让我们实现一些经典的算法：

<InteractiveCodeBlock
  code={`# 快速排序算法
def quicksort(arr):
    if len(arr) <= 1:
        return arr
    
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    return quicksort(left) + middle + quicksort(right)

# 斐波那契数列
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# 优化的斐波那契数列（使用记忆化）
def fibonacci_memo(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fibonacci_memo(n-1, memo) + fibonacci_memo(n-2, memo)
    return memo[n]

# 测试算法
print("快速排序测试:")
test_array = [64, 34, 25, 12, 22, 11, 90, 88, 76, 50]
print(f"原始数组: {test_array}")
sorted_array = quicksort(test_array)
print(f"排序后: {sorted_array}")

print(f"\n斐波那契数列前10项:")
for i in range(10):
    print(f"F({i}) = {fibonacci_memo(i)}")

# 计算执行时间对比
import time

n = 30
start = time.time()
result1 = fibonacci(n)
time1 = time.time() - start

start = time.time()
result2 = fibonacci_memo(n)
time2 = time.time() - start

print(f"\n斐波那契数列第{n}项: {result1}")
print(f"普通递归耗时: {time1:.4f}秒")
print(f"记忆化递归耗时: {time2:.4f}秒")
print(f"性能提升: {time1/time2:.1f}倍")`}
  title="算法示例"
  description="快速排序和斐波那契数列的实现"
  height={500}
/>

## 🎨 数据可视化

虽然我们在浏览器中运行Python，但仍然可以创建一些简单的文本图表：

<InteractiveCodeBlock
  code={`# 简单的文本图表
def create_bar_chart(data, width=50):
    if not data:
        return
    
    max_val = max(data.values())
    
    print("数据可视化:")
    print("=" * (width + 20))
    
    for label, value in data.items():
        # 计算条形图的长度
        bar_length = int((value / max_val) * width)
        bar = "█" * bar_length
        
        # 格式化输出
        print(f"{label:10} |{bar:<{width}} {value}")
    
    print("=" * (width + 20))

# 创建示例数据
city_population = {
    "北京": 2154,
    "上海": 2424,
    "广州": 1530,
    "深圳": 1756,
    "成都": 1658,
    "杭州": 1236,
    "武汉": 1232,
    "西安": 1295,
}

print("中国主要城市人口统计 (万人)")
create_bar_chart(city_population)

# 创建简单的散点图
print("\n\n简单散点图示例:")
print("数学成绩 vs 英语成绩")
print("Y轴: 英语成绩 (0-100)")
print("X轴: 数学成绩 (0-100)")
print()

# 使用之前的学生数据
students = [
    {"name": "张三", "math": 85, "english": 92},
    {"name": "李四", "math": 90, "english": 85},
    {"name": "王五", "math": 78, "english": 89},
    {"name": "赵六", "math": 95, "english": 87},
    {"name": "钱七", "math": 82, "english": 78},
    {"name": "孙八", "math": 88, "english": 91},
]

# 创建简单的散点图
for y in range(100, 70, -5):
    line = f"{y:3d}|"
    for x in range(70, 101, 2):
        found = False
        for student in students:
            if abs(student["math"] - x) <= 1 and abs(student["english"] - y) <= 2:
                line += "●"
                found = True
                break
        if not found:
            line += " "
    print(line)

print("   " + "+" + "-" * 15)
print("   70    80    90   100")
print("   数学成绩")`}
  title="数据可视化示例"
  description="使用文本字符创建简单的图表"
  height={400}
/>

## 🧮 面向对象编程示例

让我们创建一个简单的类来演示面向对象编程：

<InteractiveCodeBlock
  code={`class Student:
    def __init__(self, name, student_id):
        self.name = name
        self.student_id = student_id
        self.grades = {}
    
    def add_grade(self, subject, grade):
        """添加成绩"""
        if subject not in self.grades:
            self.grades[subject] = []
        self.grades[subject].append(grade)
    
    def get_average(self, subject=None):
        """获取平均分"""
        if subject:
            if subject in self.grades:
                return sum(self.grades[subject]) / len(self.grades[subject])
            return 0
        else:
            all_grades = []
            for subject_grades in self.grades.values():
                all_grades.extend(subject_grades)
            return sum(all_grades) / len(all_grades) if all_grades else 0
    
    def get_report(self):
        """生成成绩报告"""
        report = f"学生姓名: {self.name} (学号: {self.student_id})\n"
        report += "-" * 40 + "\n"
        
        for subject, grades in self.grades.items():
            avg = self.get_average(subject)
            report += f"{subject}: {grades} (平均: {avg:.1f})\n"
        
        overall_avg = self.get_average()
        report += f"\n总体平均分: {overall_avg:.1f}"
        
        return report

# 创建学生对象并测试
student1 = Student("张三", "2023001")
student2 = Student("李四", "2023002")

# 添加成绩
student1.add_grade("数学", 85)
student1.add_grade("数学", 90)
student1.add_grade("英语", 88)
student1.add_grade("英语", 92)
student1.add_grade("物理", 87)

student2.add_grade("数学", 78)
student2.add_grade("数学", 85)
student2.add_grade("英语", 91)
student2.add_grade("英语", 89)
student2.add_grade("物理", 93)

# 生成报告
print(student1.get_report())
print("\n" + "=" * 40 + "\n")
print(student2.get_report())

# 比较两个学生的数学成绩
print(f"\n数学成绩比较:")
print(f"{student1.name}: {student1.get_average('数学'):.1f}")
print(f"{student2.name}: {student2.get_average('数学'):.1f}")

better_student = student1 if student1.get_average('数学') > student2.get_average('数学') else student2
print(f"数学成绩更好的是: {better_student.name}")`}
  title="面向对象编程示例"
  description="创建学生类来管理成绩"
  height={450}
/>

## 🎉 总结

通过这些示例，我们展示了PyBlog的强大功能：

1. **即时执行**: 代码在浏览器中立即运行，无需服务器
2. **交互式学习**: 读者可以修改代码并立即看到结果
3. **丰富的功能**: 支持复杂的数据处理、算法和面向对象编程
4. **易于使用**: 只需在MDX文章中插入`<InteractiveCodeBlock>`组件

### 下一步

- 探索更多Python内置库的功能
- 学习如何处理更复杂的数据结构
- 尝试创建自己的交互式教程

---

*感谢阅读！如果您有任何问题或建议，请随时联系我们。*

</Layout> 